// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sedachain/sophon/v1/sophon.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Module parameters which can be changed through the authority.
type Params struct {
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a2a5bb229138273, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// SophonInfo contains information about a Sophon.
type SophonInfo struct {
	// The unique identifier of the Sophon. Only used for internal purposes to
	// allow key rotation.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// This address is allowed to update the config of the Sophon.
	OwnerAddress string `protobuf:"bytes,2,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`
	// This address is allowed to perform administrative actions on the Sophon.
	AdminAddress string `protobuf:"bytes,3,opt,name=admin_address,json=adminAddress,proto3" json:"admin_address,omitempty"`
	// The address of the Sophon that's used to submit reports.
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	// The public key of the Sophon used to verify signed requests.
	PublicKey []byte `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// The memo of the Sophon.
	Memo string `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo,omitempty"`
	// The balance of the Sophon.
	Balance cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=balance,proto3,customtype=cosmossdk.io/math.Int" json:"balance"`
	// The user credits a Sophon has used but not yet settled with the balance.
	UsedCredits cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=used_credits,json=usedCredits,proto3,customtype=cosmossdk.io/math.Int" json:"used_credits"`
}

func (m *SophonInfo) Reset()         { *m = SophonInfo{} }
func (m *SophonInfo) String() string { return proto.CompactTextString(m) }
func (*SophonInfo) ProtoMessage()    {}
func (*SophonInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a2a5bb229138273, []int{1}
}
func (m *SophonInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SophonInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SophonInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SophonInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SophonInfo.Merge(m, src)
}
func (m *SophonInfo) XXX_Size() int {
	return m.Size()
}
func (m *SophonInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SophonInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SophonInfo proto.InternalMessageInfo

func (m *SophonInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SophonInfo) GetOwnerAddress() string {
	if m != nil {
		return m.OwnerAddress
	}
	return ""
}

func (m *SophonInfo) GetAdminAddress() string {
	if m != nil {
		return m.AdminAddress
	}
	return ""
}

func (m *SophonInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SophonInfo) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *SophonInfo) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

// A user of a Sophon.
type SophonUser struct {
	// The identifier of the user, should be unique for a Sophon.
	UserId []byte `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The amount of credits the user has.
	Credits cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=credits,proto3,customtype=cosmossdk.io/math.Int" json:"credits"`
}

func (m *SophonUser) Reset()         { *m = SophonUser{} }
func (m *SophonUser) String() string { return proto.CompactTextString(m) }
func (*SophonUser) ProtoMessage()    {}
func (*SophonUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a2a5bb229138273, []int{2}
}
func (m *SophonUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SophonUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SophonUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SophonUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SophonUser.Merge(m, src)
}
func (m *SophonUser) XXX_Size() int {
	return m.Size()
}
func (m *SophonUser) XXX_DiscardUnknown() {
	xxx_messageInfo_SophonUser.DiscardUnknown(m)
}

var xxx_messageInfo_SophonUser proto.InternalMessageInfo

func (m *SophonUser) GetUserId() []byte {
	if m != nil {
		return m.UserId
	}
	return nil
}

// A report of a user's usage of the sophon.
type UserReport struct {
	// The identifier of the user.
	UserId []byte `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The amount of credits the user has used. Includes the computation credits
	// AND the data proxy credits.
	UsedCredits cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=used_credits,json=usedCredits,proto3,customtype=cosmossdk.io/math.Int" json:"used_credits"`
	// The reports of the data proxy queries made for the user.
	DataProxyReports []*DataProxyReport `protobuf:"bytes,3,rep,name=data_proxy_reports,json=dataProxyReports,proto3" json:"data_proxy_reports,omitempty"`
	// The number of queries made for the user.
	Queries uint64 `protobuf:"varint,4,opt,name=queries,proto3" json:"queries,omitempty"`
}

func (m *UserReport) Reset()         { *m = UserReport{} }
func (m *UserReport) String() string { return proto.CompactTextString(m) }
func (*UserReport) ProtoMessage()    {}
func (*UserReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a2a5bb229138273, []int{3}
}
func (m *UserReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserReport.Merge(m, src)
}
func (m *UserReport) XXX_Size() int {
	return m.Size()
}
func (m *UserReport) XXX_DiscardUnknown() {
	xxx_messageInfo_UserReport.DiscardUnknown(m)
}

var xxx_messageInfo_UserReport proto.InternalMessageInfo

func (m *UserReport) GetUserId() []byte {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *UserReport) GetDataProxyReports() []*DataProxyReport {
	if m != nil {
		return m.DataProxyReports
	}
	return nil
}

func (m *UserReport) GetQueries() uint64 {
	if m != nil {
		return m.Queries
	}
	return 0
}

// A report of a user's usage of a data proxy.
type DataProxyReport struct {
	// The public key of the data proxy as a hex string.
	DataProxyPubKey string `protobuf:"bytes,1,opt,name=data_proxy_pub_key,json=dataProxyPubKey,proto3" json:"data_proxy_pub_key,omitempty"`
	// The price of the data proxy in aseda when the query was made.
	Price cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.Int" json:"price"`
	// The amount of data proxy queries for the data proxy/price pair.
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *DataProxyReport) Reset()         { *m = DataProxyReport{} }
func (m *DataProxyReport) String() string { return proto.CompactTextString(m) }
func (*DataProxyReport) ProtoMessage()    {}
func (*DataProxyReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a2a5bb229138273, []int{4}
}
func (m *DataProxyReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProxyReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataProxyReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataProxyReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProxyReport.Merge(m, src)
}
func (m *DataProxyReport) XXX_Size() int {
	return m.Size()
}
func (m *DataProxyReport) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProxyReport.DiscardUnknown(m)
}

var xxx_messageInfo_DataProxyReport proto.InternalMessageInfo

func (m *DataProxyReport) GetDataProxyPubKey() string {
	if m != nil {
		return m.DataProxyPubKey
	}
	return ""
}

func (m *DataProxyReport) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "sedachain.sophon.v1.Params")
	proto.RegisterType((*SophonInfo)(nil), "sedachain.sophon.v1.SophonInfo")
	proto.RegisterType((*SophonUser)(nil), "sedachain.sophon.v1.SophonUser")
	proto.RegisterType((*UserReport)(nil), "sedachain.sophon.v1.UserReport")
	proto.RegisterType((*DataProxyReport)(nil), "sedachain.sophon.v1.DataProxyReport")
}

func init() { proto.RegisterFile("sedachain/sophon/v1/sophon.proto", fileDescriptor_8a2a5bb229138273) }

var fileDescriptor_8a2a5bb229138273 = []byte{
	// 545 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xc1, 0x6e, 0x13, 0x3d,
	0x10, 0x8e, 0xd3, 0x6d, 0xf2, 0xd7, 0xcd, 0xdf, 0x22, 0x53, 0x60, 0xa9, 0xc4, 0x36, 0x8a, 0x38,
	0x44, 0xaa, 0xb2, 0x51, 0xca, 0x0d, 0x89, 0x43, 0x0b, 0x1c, 0xa2, 0x4a, 0x28, 0x72, 0xc5, 0x85,
	0xcb, 0xca, 0xbb, 0x36, 0x89, 0xd5, 0xec, 0x7a, 0xb1, 0xbd, 0xa5, 0x79, 0x0b, 0x8e, 0x70, 0xe3,
	0x21, 0xfa, 0x10, 0x3d, 0x56, 0x3d, 0x21, 0x0e, 0x15, 0x4a, 0x2e, 0x3c, 0x06, 0xb2, 0xbd, 0x1b,
	0xa9, 0x15, 0xa8, 0xa2, 0xdc, 0x3c, 0x33, 0xdf, 0x37, 0xdf, 0xcc, 0xee, 0x67, 0xc3, 0xb6, 0x62,
	0x94, 0x24, 0x13, 0xc2, 0xb3, 0xbe, 0x12, 0xf9, 0x44, 0x64, 0xfd, 0x93, 0x41, 0x79, 0x0a, 0x73,
	0x29, 0xb4, 0x40, 0xf7, 0x97, 0x88, 0xb0, 0xcc, 0x9f, 0x0c, 0xb6, 0xb7, 0xc6, 0x62, 0x2c, 0x6c,
	0xbd, 0x6f, 0x4e, 0x0e, 0xba, 0xfd, 0x38, 0x11, 0x2a, 0x15, 0x2a, 0x72, 0x05, 0x17, 0xb8, 0x52,
	0x67, 0x03, 0x36, 0x46, 0x44, 0x92, 0x54, 0x3d, 0xf7, 0x7e, 0x7e, 0xdd, 0x01, 0x9d, 0xcf, 0x2b,
	0x10, 0x1e, 0xd9, 0x76, 0xc3, 0xec, 0xbd, 0x40, 0x1b, 0xb0, 0xce, 0xa9, 0x0f, 0xda, 0xa0, 0xeb,
	0xe1, 0x3a, 0xa7, 0xe8, 0x05, 0xfc, 0x5f, 0x7c, 0xcc, 0x98, 0x8c, 0x08, 0xa5, 0x92, 0x29, 0xe5,
	0xd7, 0xdb, 0xa0, 0xbb, 0x76, 0xe0, 0x5f, 0x9e, 0xf5, 0xb6, 0xca, 0xbe, 0xfb, 0xae, 0x72, 0xa4,
	0x25, 0xcf, 0xc6, 0xb8, 0x65, 0xe1, 0x65, 0xce, 0xd0, 0x09, 0x4d, 0x79, 0xb6, 0xa4, 0xaf, 0xdc,
	0x46, 0xb7, 0xf0, 0x8a, 0xbe, 0x07, 0x9b, 0x15, 0xd1, 0xbb, 0x85, 0x58, 0x01, 0xd1, 0x13, 0x08,
	0xf3, 0x22, 0x9e, 0xf2, 0x24, 0x3a, 0x66, 0x33, 0x7f, 0xb5, 0x0d, 0xba, 0x2d, 0xbc, 0xe6, 0x32,
	0x87, 0x6c, 0x86, 0x10, 0xf4, 0x52, 0x96, 0x0a, 0xbf, 0x61, 0xfa, 0x61, 0x7b, 0x46, 0xaf, 0x61,
	0x33, 0x26, 0x53, 0x92, 0x25, 0xcc, 0x6f, 0x5a, 0x99, 0xdd, 0xf3, 0xab, 0x9d, 0xda, 0xf7, 0xab,
	0x9d, 0x07, 0x4e, 0x4a, 0xd1, 0xe3, 0x90, 0x8b, 0x7e, 0x4a, 0xf4, 0x24, 0x1c, 0x66, 0xfa, 0xf2,
	0xac, 0x07, 0xcb, 0x19, 0x86, 0x99, 0xc6, 0x15, 0x17, 0xbd, 0x81, 0xad, 0x42, 0x31, 0x1a, 0x25,
	0x92, 0x51, 0xae, 0x95, 0xff, 0xdf, 0xdf, 0xf7, 0x5a, 0x37, 0x0d, 0x5e, 0x3a, 0x7e, 0x67, 0x5a,
	0xfd, 0x99, 0xb7, 0x8a, 0x49, 0xf4, 0x08, 0x36, 0x0b, 0xc5, 0x64, 0x54, 0xfe, 0x9e, 0x16, 0x6e,
	0x98, 0x70, 0x48, 0xcd, 0xf4, 0x95, 0x62, 0xfd, 0x0e, 0xd3, 0x97, 0xdc, 0xce, 0x02, 0x40, 0x68,
	0x84, 0x30, 0xcb, 0x85, 0xd4, 0x7f, 0x96, 0xbb, 0xb9, 0x65, 0xfd, 0xdf, 0xb6, 0x44, 0x18, 0x22,
	0x4a, 0x34, 0x31, 0x5e, 0x3d, 0x9d, 0x45, 0xd2, 0xaa, 0x1b, 0x9f, 0xac, 0x74, 0xd7, 0xf7, 0x9e,
	0x86, 0xbf, 0xf1, 0x7c, 0xf8, 0x8a, 0x68, 0x32, 0x32, 0x68, 0x37, 0x2a, 0xbe, 0x47, 0xaf, 0x27,
	0x14, 0xf2, 0x61, 0xf3, 0x43, 0xc1, 0x24, 0x67, 0xce, 0x37, 0x1e, 0xae, 0xc2, 0xce, 0x17, 0x00,
	0x37, 0x6f, 0xf0, 0xd1, 0xee, 0xb5, 0x09, 0xf2, 0x22, 0xb6, 0xce, 0x01, 0xd6, 0x20, 0x9b, 0xcb,
	0xde, 0xa3, 0x22, 0x36, 0xfe, 0xd9, 0x87, 0xab, 0xb9, 0xe4, 0x09, 0xbb, 0xcb, 0xde, 0x8e, 0x89,
	0x1e, 0xc2, 0x06, 0x49, 0x45, 0x91, 0x69, 0x7b, 0x1b, 0x3c, 0x5c, 0x46, 0x07, 0x87, 0xe7, 0xf3,
	0x00, 0x5c, 0xcc, 0x03, 0xf0, 0x63, 0x1e, 0x80, 0x4f, 0x8b, 0xa0, 0x76, 0xb1, 0x08, 0x6a, 0xdf,
	0x16, 0x41, 0xed, 0xdd, 0x60, 0xcc, 0xf5, 0xa4, 0x88, 0xc3, 0x44, 0xa4, 0x7d, 0xf3, 0x45, 0xec,
	0x55, 0x4e, 0xc4, 0xd4, 0x06, 0x3d, 0xf7, 0x6a, 0x9c, 0x56, 0xef, 0x86, 0x9e, 0xe5, 0x4c, 0xc5,
	0x0d, 0x8b, 0x79, 0xf6, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x24, 0x41, 0x7c, 0xa1, 0x58, 0x04, 0x00,
	0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SophonInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SophonInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SophonInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.UsedCredits.Size()
		i -= size
		if _, err := m.UsedCredits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSophon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.Balance.Size()
		i -= size
		if _, err := m.Balance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSophon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AdminAddress) > 0 {
		i -= len(m.AdminAddress)
		copy(dAtA[i:], m.AdminAddress)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.AdminAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OwnerAddress) > 0 {
		i -= len(m.OwnerAddress)
		copy(dAtA[i:], m.OwnerAddress)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.OwnerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSophon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SophonUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SophonUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SophonUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Credits.Size()
		i -= size
		if _, err := m.Credits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSophon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Queries != 0 {
		i = encodeVarintSophon(dAtA, i, uint64(m.Queries))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DataProxyReports) > 0 {
		for iNdEx := len(m.DataProxyReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProxyReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSophon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.UsedCredits.Size()
		i -= size
		if _, err := m.UsedCredits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSophon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataProxyReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProxyReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProxyReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintSophon(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSophon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DataProxyPubKey) > 0 {
		i -= len(m.DataProxyPubKey)
		copy(dAtA[i:], m.DataProxyPubKey)
		i = encodeVarintSophon(dAtA, i, uint64(len(m.DataProxyPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSophon(dAtA []byte, offset int, v uint64) int {
	offset -= sovSophon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SophonInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSophon(uint64(m.Id))
	}
	l = len(m.OwnerAddress)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = len(m.AdminAddress)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = m.Balance.Size()
	n += 1 + l + sovSophon(uint64(l))
	l = m.UsedCredits.Size()
	n += 1 + l + sovSophon(uint64(l))
	return n
}

func (m *SophonUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = m.Credits.Size()
	n += 1 + l + sovSophon(uint64(l))
	return n
}

func (m *UserReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = m.UsedCredits.Size()
	n += 1 + l + sovSophon(uint64(l))
	if len(m.DataProxyReports) > 0 {
		for _, e := range m.DataProxyReports {
			l = e.Size()
			n += 1 + l + sovSophon(uint64(l))
		}
	}
	if m.Queries != 0 {
		n += 1 + sovSophon(uint64(m.Queries))
	}
	return n
}

func (m *DataProxyReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataProxyPubKey)
	if l > 0 {
		n += 1 + l + sovSophon(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovSophon(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovSophon(uint64(m.Amount))
	}
	return n
}

func sovSophon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSophon(x uint64) (n int) {
	return sovSophon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSophon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSophon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SophonInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SophonInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SophonInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedCredits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UsedCredits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSophon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSophon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SophonUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SophonUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SophonUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = append(m.UserId[:0], dAtA[iNdEx:postIndex]...)
			if m.UserId == nil {
				m.UserId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Credits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSophon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSophon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = append(m.UserId[:0], dAtA[iNdEx:postIndex]...)
			if m.UserId == nil {
				m.UserId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedCredits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UsedCredits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProxyReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProxyReports = append(m.DataProxyReports, &DataProxyReport{})
			if err := m.DataProxyReports[len(m.DataProxyReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			m.Queries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Queries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSophon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSophon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProxyReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProxyReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProxyReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProxyPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProxyPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSophon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSophon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSophon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSophon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSophon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSophon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSophon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSophon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSophon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSophon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSophon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSophon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSophon = fmt.Errorf("proto: unexpected end of group")
)
